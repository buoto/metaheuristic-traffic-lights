---
title: "Sygnalizacja świetlna"
author: "Michał Błotniak & Adrianna Małkiewicz"
date: "10.06.2017"
output:
  pdf_document: default
  html_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)
library(knitr)
source('algorithm.R')
source('simulation.R')
```

# Realizacja
Celem projektu było rozwiązanie problemu optymalizacji działania sygnalizacji świetlnej na skrzyżowaniu. Poszukiwany
był taki podział czasu świateł, który spowodowałby minimalizację sumarycznego czasu spędzonego przez wszystkie samochody
na skrzyżowaniu. Szczegółowe informacje zostały zawarte w pliku _koncepcja.pdf_. Poniżej znajdują się również
doprecyzowane kwestie.

W zadaniu nie była brana pod uwagę przepustowość (liczba samochodów, którym udało się w ciągu całej doby przejechać).
Za wartość minimalizowaną została przyjęta suma czasów oczekiwania samochodów na wjazd na skrzyżowanie, ponieważ tak
było zdefiniowane przydzielone zadanie. Co więcej, wartości te są od siebie zależne, więc nie zmienia to zachowania
zaimplementowanego algorytmu.

Pojęcie jednej instancji problemu zostało przedefiniowane na pojedynczy przebieg symulacji dla podanych parametrów
rozkładów. Z tego wynika, że funkcja celu jest niedeterministyczna. Pomiar jakości otrzymanego punktu będzie zatem
wymagał wielokrotnego obliczenia funkcji celu.

## Symulacja (_simulation.R_)
Zadaniem tego modułu było zasymulowanie ruchu samochodów na skrzyżowaniu dla podanych czasów zmiany świateł oraz
rozkładów prawdopodobieństwa przyjazdów samochodów z każdej strony skrzyżowania o określonej porze dnia. Czas przejazdu
jednego samochodu przez skrzyżowanie został zamodelowany poprzez połówkowy rozkład normalny, zamiast normalnego - daje
to pewność, że czas przejazdu przez skrzyżownanie nie będzie ujemny.

Na początku każdego kroku algorytmu, na podstawie rozkładu prawdopodobieństwa dla danej pory dnia, symulowany jest
przyjazd samochodów na skrzyżowanie. Następnie, przejeżdżają kolejno samochody z kierunków N/S, przez czas określony
parametrem dla tego kroku. Jeśli wszystkie samochody z tych kierunków przejadą, to prostopadłe kierunki czekają na
zmianę światła, a następnie przejeżdżają przez skrzyżowanie do końca czasu bieżącego kroku. Jeśli światło zmieni się
zanim wszystkie samochody zjadą ze skrzyżowania, to czekają na kolejną zmianę świateł.

Dodatkowo w trakcie każdego cyklu świateł sumowany jest czas przebywania samochodów na skrzyżowaniu - od chwili
przyjazdu, do czasu ruszenia ze skrzyżowania. W ten sposób określana jest jakość przekazanego jako argument punktu
przestrzeni problemu.

## Metaheurystyka
Podczas eksperymentów dostrajane były parametry ...
# TODO

# Przebieg eksperymentów
Na początku zostały przyjęte intuicyjnie przykładowe wartości parametrów symulacji.

```{r init traffic}
trafficDists <- list(morning = c(16, 15, 4, 7),
                     noon = c(8, 9, 12, 3),
                     afternoon = c(15, 16, 6, 6),
                     night = c(3, 2, 0.5, 1))
```

Powyższa lista zawiera wektory wartości oczekiwanych rozkładów natężenia ruchu (liczba samochodów przyjeżdżających
w kwancie czasu): z każdego kierunku i dla kolejnych pór dnia. W eksperymentach został przyjęty podział doby
na 720 kawałków (po 2 minuty), w trakcie których każdorazowo dokonywana jest zmiana świateł.

Dodatkowo, wykorzystywany jest punkt referencyjny `ref`, reprezentujący strategię, w której zmiana świateł następuje co
minutę (po równo dla obu stron skrzyżowania):

```{r init rep}
ref <- rep(1/2, 720)
```

## Dobór współczynnika theta
Początkowo został poddany analizie wpływ współczynnika `theta` połówkowego rozkładu normalnego, opisującego czas
przejazdu przez skrzyżowanie. Współczynnik ten ma wprost przełożenie na wartość średnią liczby samochodów
przejeżdżających przez skrzyżowanie w trakcie jednego kwantu czasu (2 minuty), co wynika z charakterystyki połówkowego
rozkładu normalnego.

Poniżej znajduje się tabela z wynikami pomiarów dla wartości $\theta$ z przedziału od 1 do 20. Model zwraca wyniki w
kwantach czasowych równych 2 minuty.

# TODO remove unnecessary part
```{r theta}
reps <- 2 # TODO more on prod
thetas <- seq(1, 60, length = 20)

results <- list()
for (theta in thetas) {
  a <- replicate(reps, simulate(ref, trafficDists = trafficDists, list(theta = theta)))
  results <- c(results, list(a))
}

m <- results %>% sapply(mean)
s <- results %>% sapply(sd)
df <- data.frame(theta = thetas, t =1/thetas * 120, mean = m, sd = s, cv = s/m)
kable(df, col.names = c('$\\theta$', '$t$', '$\\mu_a$', '$\\sigma_a$', '$c_v$'),
      caption = paste('Wyniki pomiarów dla ', reps, ' powtórzeń z różnymi wartościami $\\theta$.'))
```

### Wnioski

Z powyższych danych wynika, że współczynnik zmienności wartości zwracanych przez model $c_v$ maleje wraz ze wzrostem
$\theta$, a od pewnego momentu utrzymuje się na stałym poziomie. Dodatkowo uśrednione wartości zwracane przez model
$\mu_a$ spadają do $4300$ kwantów czasu.

Oznacza to, że wszystkie samochody czekały łącznie mniej niż połowę doby. Jest to niepożądane zjawisko, spowodowane zbyt
dużą wartością współczynnika $\theta$ (znacznie większą niż największa wartość oczekiwana natężenia ruchu, która była
równa 16). W takiej sytuacji samochody przejeżdżają tak szybko w stosunku do ich przybywania, że optymalną strategią jest
przełączanie świateł w proporcjach $1:1$ charakteryzjących punkt referencyjny `ref`.

Wynika stąd, że algorytm będzie miał przewagę dla wartości $\theta$ bliskich `max(trafficDists)` oraz mniejszych od tej
wartości.

## Analiza działania algorytmu



# TODO hide unnecessary part
```{r run algorithm, message=FALSE, warning=FALSE}
h.1 <- function(parameters) simulate(parameters,
         list(morning = c(2, 3, 1, 0.5), noon = c(0.5, 0.5, 0.2, 0.1), afternoon = c(4, 5, 2, 1), night = c(0.3, 0.2, 0.05, 0.1)),
         list(theta = 4))
refn.1 <- replicate(reps, h.1(ref))
solution.1 <- mea(replicate(720, c(0, 1), simplify = FALSE), 10, h.1, maxSteps = 100, mutationMean = 0.01)
soln.1 <- replicate(reps, h.1(solution.1$point))

df <- data.frame(mean = c(mean(soln.1), mean(refn.1)), sd = c(sd(soln.1), sd(refn.1)))
rownames(df) <- c('Najlepszy algorytmu', 'Punkt referencyjny')
kable(df,
      col.names = c('$\\mu_a$', '$\\sigma$'),
      caption = paste('Wyniki pomiarów dla ', reps, ' powtórzeń z różnymi wartościami $\\theta$.'))

boxplot(list(algorytm = soln.1, ref = refn.1))
#text('Rozkłady wartości wyników symulacji dla najlepszego punktu otrzymanego przez algorytm i punktu referencyjnego.')
```
